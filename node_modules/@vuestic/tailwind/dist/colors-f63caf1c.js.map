{"version":3,"file":"colors-f63caf1c.js","sources":["../../../node_modules/pathe/dist/shared/pathe.ff20891b.mjs","../helpers/helpers.ts","../../ui/dist/es/src/services/color/presets.js","../../ui/dist/es/src/services/breakpoint/index.js","../modules/breakpoint.ts","../modules/colors.ts"],"sourcesContent":["const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\\//;\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());\n}\n\nconst _UNC_REGEX = /^[/\\\\]{2}/;\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nconst _DRIVE_LETTER_RE = /^[A-Za-z]:$/;\nconst _ROOT_FOLDER_RE = /^\\/([A-Za-z]:)?$/;\nconst sep = \"/\";\nconst delimiter = \":\";\nconst normalize = function(path) {\n  if (path.length === 0) {\n    return \".\";\n  }\n  path = normalizeWindowsPath(path);\n  const isUNCPath = path.match(_UNC_REGEX);\n  const isPathAbsolute = isAbsolute(path);\n  const trailingSeparator = path[path.length - 1] === \"/\";\n  path = normalizeString(path, !isPathAbsolute);\n  if (path.length === 0) {\n    if (isPathAbsolute) {\n      return \"/\";\n    }\n    return trailingSeparator ? \"./\" : \".\";\n  }\n  if (trailingSeparator) {\n    path += \"/\";\n  }\n  if (_DRIVE_LETTER_RE.test(path)) {\n    path += \"/\";\n  }\n  if (isUNCPath) {\n    if (!isPathAbsolute) {\n      return `//./${path}`;\n    }\n    return `//${path}`;\n  }\n  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;\n};\nconst join = function(...arguments_) {\n  if (arguments_.length === 0) {\n    return \".\";\n  }\n  let joined;\n  for (const argument of arguments_) {\n    if (argument && argument.length > 0) {\n      if (joined === void 0) {\n        joined = argument;\n      } else {\n        joined += `/${argument}`;\n      }\n    }\n  }\n  if (joined === void 0) {\n    return \".\";\n  }\n  return normalize(joined.replace(/\\/\\/+/g, \"/\"));\n};\nfunction cwd() {\n  if (typeof process !== \"undefined\" && typeof process.cwd === \"function\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n    const path = index >= 0 ? arguments_[index] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index = 0; index <= path.length; ++index) {\n    if (index < path.length) {\n      char = path[index];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p) {\n  return _IS_ABSOLUTE_RE.test(p);\n};\nconst toNamespacedPath = function(p) {\n  return normalizeWindowsPath(p);\n};\nconst _EXTNAME_RE = /.(\\.[^./]+)$/;\nconst extname = function(p) {\n  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));\n  return match && match[1] || \"\";\n};\nconst relative = function(from, to) {\n  const _from = resolve(from).replace(_ROOT_FOLDER_RE, \"$1\").split(\"/\");\n  const _to = resolve(to).replace(_ROOT_FOLDER_RE, \"$1\").split(\"/\");\n  if (_to[0][1] === \":\" && _from[0][1] === \":\" && _from[0] !== _to[0]) {\n    return _to.join(\"/\");\n  }\n  const _fromCopy = [..._from];\n  for (const segment of _fromCopy) {\n    if (_to[0] !== segment) {\n      break;\n    }\n    _from.shift();\n    _to.shift();\n  }\n  return [..._from.map(() => \"..\"), ..._to].join(\"/\");\n};\nconst dirname = function(p) {\n  const segments = normalizeWindowsPath(p).replace(/\\/$/, \"\").split(\"/\").slice(0, -1);\n  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {\n    segments[0] += \"/\";\n  }\n  return segments.join(\"/\") || (isAbsolute(p) ? \"/\" : \".\");\n};\nconst format = function(p) {\n  const segments = [p.root, p.dir, p.base ?? p.name + p.ext].filter(Boolean);\n  return normalizeWindowsPath(\n    p.root ? resolve(...segments) : segments.join(\"/\")\n  );\n};\nconst basename = function(p, extension) {\n  const lastSegment = normalizeWindowsPath(p).split(\"/\").pop();\n  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;\n};\nconst parse = function(p) {\n  const root = normalizeWindowsPath(p).split(\"/\").shift() || \"/\";\n  const base = basename(p);\n  const extension = extname(base);\n  return {\n    root,\n    dir: dirname(p),\n    base,\n    ext: extension,\n    name: base.slice(0, base.length - extension.length)\n  };\n};\n\nconst path = {\n  __proto__: null,\n  basename: basename,\n  delimiter: delimiter,\n  dirname: dirname,\n  extname: extname,\n  format: format,\n  isAbsolute: isAbsolute,\n  join: join,\n  normalize: normalize,\n  normalizeString: normalizeString,\n  parse: parse,\n  relative: relative,\n  resolve: resolve,\n  sep: sep,\n  toNamespacedPath: toNamespacedPath\n};\n\nexport { normalize as a, normalizeString as b, relative as c, delimiter as d, extname as e, dirname as f, format as g, basename as h, isAbsolute as i, join as j, parse as k, normalizeWindowsPath as n, path as p, resolve as r, sep as s, toNamespacedPath as t };\n","import fs from 'fs'\nimport { resolve } from 'pathe'\n\nexport const defaultTailwindConfigFilename = 'tailwind.config.cjs'\nexport const tailwindConfigFilename = fs.readdirSync('.').find((fileName: string) => fileName.startsWith('tailwind.config.'))\nexport const tailwindConfigPath = tailwindConfigFilename ? resolve(process.cwd(), tailwindConfigFilename) : undefined\n\n/**\n * @param value any value for converting it to raw string\n * @param nestingLevel current nesting level (is needed for correct indents)\n * @returns raw string value\n */\nexport const convertValueToString = (value: any, nestingLevel = 1): string => {\n  const result: string[] = []\n\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    result.push('{\\n')\n\n    for (const prop in value) {\n      // if prop contains both numbers and literals and/or dashes we wrap it with quotes\n      const correctProp = /(?=.*\\d)(?=.*[a-z])|(?=.*-)/i.test(prop) ? `'${prop}'` : prop\n\n      result.push('\\t'.repeat(nestingLevel) + correctProp, ': ', convertValueToString(value[prop], nestingLevel + 1), ',\\n')\n    }\n\n    result.push('\\t'.repeat(nestingLevel - 1) + '}')\n  } else if (typeof value === 'object' && Array.isArray(value)) {\n    result.push('[\\n')\n\n    for (const prop in value) {\n      result.push(convertValueToString(value[prop], nestingLevel + 1), ',\\n')\n    }\n\n    result.push(']')\n  } else if (typeof value === 'number') {\n    result.push(String(value))\n  } else {\n    result.push(`'${value}'`)\n  }\n\n  return result.join('')\n}\n","const presets = {\n  light: {\n    // Accent\n    primary: \"#154EC1\",\n    secondary: \"#767C88\",\n    success: \"#3D9209\",\n    info: \"#158DE3\",\n    danger: \"#E42222\",\n    warning: \"#FFD43A\",\n    // Background Colors\n    backgroundPrimary: \"#f6f6f6\",\n    backgroundSecondary: \"#FFFFFF\",\n    backgroundElement: \"#ECF0F1\",\n    backgroundBorder: \"#DEE5F2\",\n    // Text Colors\n    textPrimary: \"#262824\",\n    textInverted: \"#FFFFFF\",\n    // Misc\n    shadow: \"rgba(0, 0, 0, 0.12)\",\n    focus: \"#49A8FF\",\n    transparent: \"rgba(0, 0, 0, 0)\"\n  },\n  dark: {\n    // Accent\n    primary: \"#3472F0\",\n    secondary: \"#767C88\",\n    success: \"#66BE33\",\n    info: \"#3EAAF8\",\n    danger: \"#F34030\",\n    warning: \"#FFD952\",\n    // Background Colors\n    backgroundPrimary: \"#050A10\",\n    backgroundSecondary: \"#1F262F\",\n    backgroundElement: \"#131A22\",\n    backgroundBorder: \"#3D4C58\",\n    // Text Colors\n    textPrimary: \"#F1F1F1\",\n    textInverted: \"#0B121A\",\n    // Misc\n    shadow: \"rgba(255, 255, 255, 0.12)\",\n    focus: \"#49A8FF\",\n    transparent: \"rgba(0, 0, 0, 0)\"\n  }\n};\nexport {\n  presets as p\n};\n//# sourceMappingURL=presets.js.map\n","const vaBreakpointSymbol = Symbol(\"vaBreakpoint\");\nconst defaultThresholds = {\n  xs: 0,\n  sm: 640,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst getBreakpointDefaultConfig = () => ({\n  enabled: true,\n  bodyClass: true,\n  thresholds: defaultThresholds\n});\nexport {\n  defaultThresholds as d,\n  getBreakpointDefaultConfig as g,\n  vaBreakpointSymbol as v\n};\n//# sourceMappingURL=index.js.map\n","import { thresholdsPreset } from 'vuestic-ui'\n\ntype VuesticThresholdsList = Record<string, number>\ntype TailwindScreensConfig = Record<string, string>\n\n/**\n * @param thresholds tailwind css screens settings\n * @returns vuestic ui thresholds settings\n */\nconst convertTailwindThresholds = (thresholds: TailwindScreensConfig): VuesticThresholdsList => {\n  return Object.entries(thresholds)\n    .reduce((acc, [key, value]) => {\n      const vuesticThreshold = Number(value.substring(0, value.length - 2))\n\n      isNaN(vuesticThreshold) && console.warn(`${value} isn't correct Tailwind CSS screen!`)\n      if (!isNaN(vuesticThreshold)) {\n        acc[key] = vuesticThreshold\n      }\n\n      return acc\n    }, {} as VuesticThresholdsList)\n}\n\n/**\n * @param tailwindConfig users or default tailwind css config\n * @returns vuestic ui breakpoint config\n */\nexport const tailwindThresholdsSync = (tailwindConfig?: Record<string, any>): VuesticThresholdsList => {\n  let tailwindThresholds\n\n  if (tailwindConfig) {\n    const tailwindThresholdsConfig = tailwindConfig.theme?.screens || tailwindConfig.theme?.extend?.screens\n    if (tailwindThresholdsConfig) { tailwindThresholds = convertTailwindThresholds(tailwindThresholdsConfig) }\n  }\n\n  const isTailwindScreensConfigOverwritten = !!Object.keys(tailwindConfig?.theme?.screens || {}).length\n  const defaultTailwindConfig = require('tailwindcss/defaultTheme')\n  const tailwindDefaultScreensConverted = convertTailwindThresholds(defaultTailwindConfig.screens)\n\n  if (!tailwindThresholds) {\n    tailwindThresholds = tailwindDefaultScreensConverted\n  } else if (tailwindThresholds && !isTailwindScreensConfigOverwritten) {\n    tailwindThresholds = { ...tailwindDefaultScreensConverted, ...tailwindThresholds }\n  }\n\n  return tailwindThresholds\n}\n\n/**\n * @returns tailwind ui thresholds settings\n */\nexport const convertVuesticThresholds = (current: Record<string, any>): TailwindScreensConfig => {\n  const currentThresholdsConfig = { ...(current.theme.extend.screens || {}) }\n\n  if (!thresholdsPreset) {\n    console.warn(\"Vuestic UI default thresholds preset wasn't found!\")\n    return currentThresholdsConfig\n  }\n\n  const vuesticThresholdsConverted = Object.entries(thresholdsPreset)\n    .reduce((acc, [key, value]) => {\n      acc[key] = `${value}px`\n      return acc\n    }, {} as TailwindScreensConfig)\n\n  return { ...currentThresholdsConfig, ...vuesticThresholdsConverted }\n}\n","import { colorsPreset } from 'vuestic-ui'\n\ntype VuesticColorsList = Record<string, string>\ntype TailwindColorsConfig = Record<string, string | Record<string, string>>\n\n/**\n * @param colors tailwind css colors options\n * @returns vuestic ui colors options\n */\nconst convertTailwindColors = (colors: TailwindColorsConfig): VuesticColorsList => {\n  // system and deprecated by tailwind\n  const ignoredColors = ['inherit', 'current', 'transparent', 'coolGray', 'blueGray', 'trueGray', 'warmGray', 'lightBlue']\n  const result = {} as VuesticColorsList\n\n  for (const prop in colors) {\n    if (!ignoredColors.includes(prop)) {\n      const propValue = colors[prop]\n      if (typeof propValue === 'object') {\n        for (const nestedProp in (colors[prop] as Record<string, string>)) {\n          result[`${prop}-${nestedProp}`] = propValue[nestedProp]\n        }\n      } else {\n        result[prop] = <string>colors[prop]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * @param tailwindConfig users or default tailwind config\n * @returns vuestic colors config\n */\nexport const tailwindColorsSync = (tailwindConfig?: Record<string, any>): VuesticColorsList => {\n  let tailwindColors\n\n  if (tailwindConfig) {\n    const tailwindColorsConfig = tailwindConfig.theme?.colors || tailwindConfig.theme?.extend?.colors\n    if (tailwindColorsConfig) { tailwindColors = convertTailwindColors(tailwindColorsConfig) }\n  }\n\n  const isTailwindColorsConfigOverwritten = !!Object.keys(tailwindConfig?.theme?.colors || {}).length\n  const tailwindDefaultColors = require('tailwindcss/colors')\n  const tailwindDefaultColorsConverted = convertTailwindColors(tailwindDefaultColors)\n\n  if (!tailwindColors) {\n    tailwindColors = tailwindDefaultColorsConverted\n  } else if (tailwindColors && !isTailwindColorsConfigOverwritten) {\n    tailwindColors = { ...tailwindDefaultColorsConverted, ...tailwindColors }\n  }\n\n  return tailwindColors\n}\n\n/**\n * @param current current tailwind css config\n * @returns tailwind css colors options\n */\nexport const convertVuesticColors = (current: Record<string, any>): TailwindColorsConfig => {\n  const vuesticColorsPreset = colorsPreset?.light\n  const currentColorsConfig = { ...(current.theme.extend.colors || {}) }\n\n  if (!vuesticColorsPreset) {\n    console.warn(\"Vuestic UI default colors preset wasn't found!\")\n    return currentColorsConfig\n  }\n\n  return { ...currentColorsConfig, ...vuesticColorsPreset }\n}\n"],"names":["_DRIVE_LETTER_START_RE","_IS_ABSOLUTE_RE","isAbsolute","p","test","tailwindConfigFilename","fs","readdirSync","find","fileName","startsWith","tailwindConfigPath","arguments_","resolvedPath","resolvedAbsolute","index","map","argument","normalizeWindowsPath","input","replace","r","toUpperCase","length","path","process","cwd","normalizeString","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","char","lastSlashIndex","lastIndexOf","slice","resolve","convertValueToString","value","nestingLevel","result","Array","isArray","push","prop","String","correctProp","repeat","join","presets","light","primary","secondary","success","info","danger","warning","backgroundPrimary","backgroundSecondary","backgroundElement","backgroundBorder","textPrimary","textInverted","shadow","focus","transparent","dark","defaultThresholds","xs","sm","md","lg","xl","convertTailwindThresholds","thresholds","Object","entries","reduce","acc","key","vuesticThreshold","Number","substring","isNaN","console","warn","convertTailwindColors","colors","ignoredColors","includes","propValue","nestedProp","current","vuesticColorsPreset","colorsPreset","currentColorsConfig","theme","extend","currentThresholdsConfig","screens","thresholdsPreset","vuesticThresholdsConverted","tailwindConfig","tailwindColors","tailwindColorsConfig","_a","_c","_b","isTailwindColorsConfigOverwritten","keys","_d","tailwindDefaultColors","require","tailwindDefaultColorsConverted","tailwindThresholds","tailwindThresholdsConfig","isTailwindScreensConfigOverwritten","defaultTailwindConfig","tailwindDefaultScreensConverted"],"mappings":"mCAAMA,EAAyB,eAS/B,MAAMC,EAAkB,kDAwIxB,MAAMC,WAAa,SAASC,GACnB,OAAAF,EAAgBG,KAAKD,EAC9B,EC/IaE,EAAyBC,EAAGC,YAAY,KAAKC,MAAMC,GAAqBA,EAASC,WAAW,sBAC5FC,EAAqBN,ED+DlB,YAAYO,GAE1B,IAAIC,EAAe,GACfC,GAAmB,EACd,IAAA,IAAAC,GAHTH,EAAaA,EAAWI,KAAKC,GApE/B,SAASC,qBAAqBC,EAAQ,IACpC,OAAKA,EAGEA,EAAMC,QAAQ,MAAO,KAAKA,QAAQpB,GAAyBqB,GAAMA,EAAEC,gBAFjEH,CAGX,CA+D4CD,CAAqBD,MAGnCM,OAAS,EAAGR,IAAe,IAACD,EAAkBC,IAAS,CACjF,MAAMS,EAAOT,GAAS,EAAIH,EAAWG,GAVhB,oBAAZU,SAAkD,mBAAhBA,QAAQC,IAC5CD,QAAQC,MAAMN,QAAQ,MAAO,KAE/B,IAQAI,GAAwB,IAAhBA,EAAKD,SAGHV,EAAA,GAAGW,KAAQX,IAC1BC,EAAmBZ,WAAWsB,GAC/B,CAED,OADeX,EAMjB,SAASc,gBAAgBH,EAAMI,GAC7B,IAAIC,EAAM,GACNC,EAAoB,EACpBC,GAAY,EACZC,EAAO,EACPC,EAAO,KACX,IAAA,IAASlB,EAAQ,EAAGA,GAASS,EAAKD,SAAUR,EAAO,CAC7C,GAAAA,EAAQS,EAAKD,OACfU,EAAOT,EAAKT,OAClB,IAAwB,MAATkB,EACT,MAEOA,EAAA,GACR,CACD,GAAa,MAATA,EAAc,CACZ,GAAAF,IAAchB,EAAQ,GAAc,IAATiB,QAAY,GAAoB,IAATA,EAAY,CAChE,GAAIH,EAAIN,OAAS,GAA2B,IAAtBO,GAAmD,MAAxBD,EAAIA,EAAIN,OAAS,IAAsC,MAAxBM,EAAIA,EAAIN,OAAS,GAAY,CACvG,GAAAM,EAAIN,OAAS,EAAG,CACZ,MAAAW,EAAiBL,EAAIM,YAAY,MACZ,IAAvBD,GACIL,EAAA,GACcC,EAAA,IAEdD,EAAAA,EAAIO,MAAM,EAAGF,GACnBJ,EAAoBD,EAAIN,OAAS,EAAIM,EAAIM,YAAY,MAE3CJ,EAAAhB,EACLiB,EAAA,EACP,QACZ,CAAA,GAAqBH,EAAIN,OAAS,EAAG,CACnBM,EAAA,GACcC,EAAA,EACRC,EAAAhB,EACLiB,EAAA,EACP,QACD,CACF,CACGJ,IACKC,GAAAA,EAAIN,OAAS,EAAI,MAAQ,KACZO,EAAA,EAE9B,MACYD,EAAIN,OAAS,EACfM,GAAO,IAAIL,EAAKY,MAAML,EAAY,EAAGhB,KAErCc,EAAML,EAAKY,MAAML,EAAY,EAAGhB,GAElCe,EAAoBf,EAAQgB,EAAY,EAE9BA,EAAAhB,EACLiB,EAAA,CACR,KAAmB,MAATC,IAA6B,IAAbD,IACvBA,EAEKA,GAAA,CAEV,CACM,OAAAH,CACT,CAhEiBF,CAAgBd,GAAeC,GAC1CA,IAAqBZ,WAAWW,GAC3B,IAAIA,IAENA,EAAaU,OAAS,EAAIV,EAAe,GAClD,CChF2DwB,CAAQZ,QAAQC,MAAOrB,QAA0B,EAO/FiC,qBAAuB,CAACC,EAAYC,EAAe,KAC9D,MAAMC,EAAmB,GAEzB,GAAqB,iBAAVF,GAAuBG,MAAMC,QAAQJ,MAWpB,iBAAVA,GAAsBG,MAAMC,QAAQJ,GAAQ,CAC5DE,EAAOG,KAAK,OAEZ,IAAA,MAAWC,KAAQN,EACVE,EAAAG,KAAKN,qBAAqBC,EAAMM,GAAOL,EAAe,GAAI,OAGnEC,EAAOG,KAAK,IAAG,KACW,iBAAVL,EACTE,EAAAG,KAAKE,OAAOP,IAEZE,EAAAG,KAAK,IAAIL,UAtBsC,CACtDE,EAAOG,KAAK,OAEZ,IAAA,MAAWC,KAAQN,EAAO,CAExB,MAAMQ,EAAc,+BAA+B3C,KAAKyC,GAAQ,IAAIA,KAAUA,EAE9EJ,EAAOG,KAAK,KAAKI,OAAOR,GAAgBO,EAAa,KAAMT,qBAAqBC,EAAMM,GAAOL,EAAe,GAAI,MAClH,CAEAC,EAAOG,KAAK,KAAKI,OAAOR,EAAe,GAAK,IAAG,CAe1C,OAAAC,EAAOQ,KAAK,GAAE,ECxCjBC,EAAU,CACdC,MAAO,CAELC,QAAS,UACTC,UAAW,UACXC,QAAS,UACTC,KAAM,UACNC,OAAQ,UACRC,QAAS,UAETC,kBAAmB,UACnBC,oBAAqB,UACrBC,kBAAmB,UACnBC,iBAAkB,UAElBC,YAAa,UACbC,aAAc,UAEdC,OAAQ,sBACRC,MAAO,UACPC,YAAa,oBAEfC,KAAM,CAEJf,QAAS,UACTC,UAAW,UACXC,QAAS,UACTC,KAAM,UACNC,OAAQ,UACRC,QAAS,UAETC,kBAAmB,UACnBC,oBAAqB,UACrBC,kBAAmB,UACnBC,iBAAkB,UAElBC,YAAa,UACbC,aAAc,UAEdC,OAAQ,4BACRC,MAAO,UACPC,YAAa,qBCxCXE,EAAoB,CACxBC,GAAI,EACJC,GAAI,IACJC,GAAI,KACJC,GAAI,KACJC,GAAI,MCGAC,0BAA6BC,GAC1BC,OAAOC,QAAQF,GACnBG,QAAO,CAACC,GAAMC,EAAKzC,MACZ,MAAA0C,EAAmBC,OAAO3C,EAAM4C,UAAU,EAAG5C,EAAMhB,OAAS,IAO3D,OALP6D,MAAMH,IAAqBI,QAAQC,KAAK,GAAG/C,wCACtC6C,MAAMH,KACTF,EAAIC,GAAOC,GAGNF,CAAA,GACN,CAA2B,GCX5BQ,sBAAyBC,IAEvB,MAAAC,EAAgB,CAAC,UAAW,UAAW,cAAe,WAAY,WAAY,WAAY,WAAY,aACtGhD,EAAS,CAAA,EAEf,IAAA,MAAWI,KAAQ2C,EACjB,IAAKC,EAAcC,SAAS7C,GAAO,CAC3B,MAAA8C,EAAYH,EAAO3C,GACrB,GAAqB,iBAAd8C,EACE,IAAA,MAAAC,KAAeJ,EAAO3C,GAC/BJ,EAAO,GAAGI,KAAQ+C,KAAgBD,EAAUC,QAGvCnD,EAAAI,GAAgB2C,EAAO3C,EAElC,CAGK,OAAAJ,CAAA,2IAgC4BoD,IACnC,MAAMC,EAAoC,MAAdC,OAAc,EAAA7C,EAAAC,MACpC6C,EAAsB,IAAMH,EAAQI,MAAMC,OAAOV,QAAU,CAAA,GAEjE,OAAKM,EAKE,IAAKE,KAAwBF,IAJlCT,QAAQC,KAAK,kDACNU,qCDd8BH,IACjC,MAAAM,EAA0B,IAAMN,EAAQI,MAAMC,OAAOE,SAAW,CAAA,GAEtE,IAAKC,EAEI,OADPhB,QAAQC,KAAK,sDACNa,EAGH,MAAAG,EAA6B1B,OAAOC,QAAQwB,GAC/CvB,QAAO,CAACC,GAAMC,EAAKzC,MACdwC,EAAAC,GAAO,GAAGzC,MACPwC,IACN,CAA2B,GAEhC,MAAO,IAAKoB,KAA4BG,0CH9DG,iDI+BVC,gBAC7B,IAAAC,EAEJ,GAAID,EAAgB,CACZ,MAAAE,GAAuB,OAAAC,IAAeT,YAAf,EAAAS,EAAsBlB,UAAU,OAAAmB,EAAA,OAAeC,EAAAL,EAAAN,YAAO,EAAAW,EAAAV,aAAQ,EAAAS,EAAAnB,QACvFiB,IAAwBD,EAAiBjB,sBAAsBkB,GACrE,CAEM,MAAAI,IAAsCjC,OAAOkC,MAAK,OAAAC,EAAgB,MAAAR,OAAA,EAAAA,EAAAN,YAAO,EAAAc,EAAAvB,SAAU,IAAIjE,OACvFyF,EAAwBC,QAAQ,sBAChCC,EAAiC3B,sBAAsByB,GAQtD,OANFR,EAEMA,IAAmBK,IAC5BL,EAAiB,IAAKU,KAAmCV,IAFxCA,EAAAU,EAKZV,CAAA,+FDzB8BD,gBACjC,IAAAY,EAEJ,GAAIZ,EAAgB,CACZ,MAAAa,GAA2B,OAAAV,IAAeT,YAAf,EAAAS,EAAsBN,WAAW,OAAAO,EAAA,OAAeC,EAAAL,EAAAN,YAAO,EAAAW,EAAAV,aAAQ,EAAAS,EAAAP,SAC5FgB,IAA4BD,EAAqBzC,0BAA0B0C,GACjF,CAEM,MAAAC,IAAuCzC,OAAOkC,MAAK,OAAAC,EAAgB,MAAAR,OAAA,EAAAA,EAAAN,YAAO,EAAAc,EAAAX,UAAW,IAAI7E,OACzF+F,EAAwBL,QAAQ,4BAChCM,EAAkC7C,0BAA0B4C,EAAsBlB,SAQjF,OANFe,EAEMA,IAAuBE,IAChCF,EAAqB,IAAKI,KAAoCJ,IAFzCA,EAAAI,EAKhBJ,CAAA","x_google_ignoreList":[0]}